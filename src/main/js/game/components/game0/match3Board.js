define(require => {    const msgBus = require("skbJet/component/gameMsgBus/GameMsgBus");	const PIXI = require("com/pixijs/pixi");	const displayList = require("skbJet/componentManchester/standardIW/displayList");    const audio = require("skbJet/componentManchester/standardIW/audio");    const config = require("skbJet/componentManchester/standardIW/gameConfig");    const Match3Tile = require("game/components/game0/Match3Tile");	const filterStyles = require("game/template/filterStyles");	const gameState = require("game/state/gameState");	const maths = require("skbJet/componentLondon/utils/maths");	const altAutoPlay = require("game/altAutoPlay");	require("com/gsap/TweenMax");	require("com/gsap/TimelineLite");	require("com/gsap/easing/EasePack");	const Tween = window.TweenMax;	const Timeline = window.TimelineLite;	//Variables    let sparkleTween;    let hintTween;	let hintDisplayTween;	let currentBoard;	let topRow;	let tileArray;	let tileDropArray;	let promFinish;    let bgContainer;	let crossSwapTile;	let idleEnabled;	//Game init	function init() {		//Start hint tween		hintTween = Tween.to({}, config.IDLE_HINT_INTERVAL, {			onComplete: promptHint,			paused: true		});		idleEnabled = true;		//Reset state		tileArray = [];		tileDropArray = [];		bgContainer = displayList.game0BG;		displayList.game0.on("pointerdown", cancelHint);		displayList.game0.interactive = true;		msgBus.subscribe("Game0.swapStarted", onSwapStarted);		msgBus.subscribe("Game0.swapFinished", onSwapFinished);		msgBus.subscribe("Game0.allTintsFinished", onAllTintsFinished);		msgBus.subscribe("Game0.allPopsFinished", onAllPopsFinished);		msgBus.subscribe("Game0.dropFinished", onDropFinished);		msgBus.subscribe("Game0.popCustom", onPopCustom);		msgBus.subscribe("Game0.popStarted", onPopStarted);		msgBus.subscribe("Game0.allDropsFinished", (data) => {			onSwapFinished(data);			msgBus.publish("Game.saveState", {				objectives: gameState.objectives,				moves: gameState.moves,				score: gameState.score,				scoreTS: new Date().getTime(),				board: currentBoard,				boardData: Match3Tile.save(),				seed: maths.getSeed()			});		});		msgBus.subscribe("Game0.disable", disableTiles);		msgBus.subscribe("Game0.reEnable", reEnableTiles);		msgBus.subscribe("Game0.started", onStarted);		msgBus.subscribe("Game0.finish", onFinish);		msgBus.subscribe("UI.hideHelp", reEnableTiles);		msgBus.subscribe("UI.showHelp", disableTiles);		//Switch off hints during auto reveal		msgBus.subscribe("Game.AltAutoPlayStart", disableIdle);		msgBus.subscribe("Game.AltAutoPlayStop", enableIdle);	}	function reset() {		//reset and remove tiles		tileArray.forEach(tile => {			tile.reset();			Match3Tile.remove(tile);		});		//Reset state		tileArray = [];		tileDropArray = [];	}	function enable() {		// Enable the game0 tiles		tileArray.forEach(tile => {tile.enabled = true;});		// Return a promise for the game's lifecycle        return new Promise(resolve => {			promFinish = resolve;        });    }    //Creates the tiles in the configuration selected and fills them with random icons	function createBoard(name) {		//Clear the board		tileArray.forEach(tile => {			tile.reset();			Match3Tile.remove(tile);		});		tileArray = [];		tileDropArray = [];		currentBoard = name;        topRow = [];			// spawn locations of new tiles.        if(config[currentBoard].topRow && config[currentBoard].topRow.length === config[currentBoard].bottomRow.length) {            topRow = config[currentBoard].topRow;        } else if(config[currentBoard].top) {            for(let i = 0; i < config[currentBoard].bottomRow.length; i++) {                topRow.push(config[currentBoard].top);            }        } else {            throw new Error("Bad top/bottom row config: " + currentBoard);        }        //Create the game tiles        displayList[currentBoard].children.forEach(child => {            tileArray.push(Match3Tile.fromContainer(bgContainer, child));        });		//Initial fill. Avoid putting wild tiles next to each other		tileArray.forEach(tile => {			tile.icon = Match3Tile.pickIcon(tile.neighbouringWild() ? "baseOnly" : "default");		});		//Unpop any matches, then retest (do limited passes, just in case)		let stillWrong = false;		for(let i = 0; i < config.MAX_UNPOP_PASSES; i++) {			stillWrong = false;			tileArray.forEach(tile => {				if(tile.popCount()) {					stillWrong = true;					tile.popUndo();				}			});			if(!stillWrong) {				window.tileArray = tileArray;//debug				return tileArray;			}		}		//on no		console.error("Out of unpop passes!");	}	//Hints and idle	function randomSparkleDuration() {		return config.SPARKLE_INTERVAL + (Math.random() * config.SPARKLE_INTERVAL_VARIATION);	}	function promptSparkle() {		if(idleEnabled) {			// Pick a random tile to sparkle			tileArray[Math.floor(tileArray.length * Math.random())].showSparkle();			// Restart the sparkle timer tween			sparkleTween.duration(randomSparkleDuration());			sparkleTween.play(0);		}	}	function promptHint() {		if(!altAutoPlay._enabled && !Match3Tile.DEBUG_NOSWAPS) {			//Check for hints even when disabled, in case there are none (== no swaps available)			let hint = "";			try {				hint = Match3Tile.findHint();			} catch(e) {				console.log("--- HINT REQUESTED DURING BOARD RESOLVE! ---");				return;			}			if(hint.length === 0) {				//No hint				// Check if the board is resolving				if(Match3Tile.swapping || Match3Tile.popping || Match3Tile.dropping || Match3Tile.tinting) {					cancelHint();					return;				}				//we are out of swaps.destroy all tiles				Object.keys(Match3Tile.tiles).forEach(key => {					Match3Tile.tiles[key].pop(true);				});				msgBus.publish("Game0.outOfSwaps");			} else if(idleEnabled && gameState.moves > 0) {				hint.forEach(tile => {					tile.showHint();					tile.showSparkle();				});				hintDisplayTween = Tween.fromTo(filterStyles.hint, config.IDLE_HINT_DURATION / 2, {brightness: 1}, {brightness: 2, repeat: -1, yoyo: true});			}		}	}	function cancelHint() {		if(hintDisplayTween) {			hintDisplayTween.kill();			Tween.to(				filterStyles.hint,				config.IDLE_HINT_CANCEL,				{brightness: 1, onComplete: () => tileArray.forEach(tile => tile.hideHint())}			);		}		//restart hint tween on cancel		if(idleEnabled) {			hintTween.play(0);		}	}	function enableIdle() {		idleEnabled = true;		hintTween.play(0);		//sparkleTween.play(0);	}	function disableIdle() {		cancelHint();		idleEnabled = false;	}	//Game flow	//Clear tileDropArray when the player makes a swap	function onSwapStarted() {		tileDropArray = [];		crossSwapTile = null;	}	//When icons are swapped, check for wilds	function onSwapFinished(data) {		if(data && config.iconPairs.includes(data.source.icon) && config.iconPairs.includes(data.destination.icon)) {			//JesÃºs swap			data.source.icon = config.iconFamilies[data.source._iconFamily][0]; //Demote 'other' stripey to a normal fruit			crossSwapTile = data.destination;			data.destination.pop(true);		}		//Count matches		tileArray.forEach(tile => {			tile.popCount();		});		//Tint any wilds that can pop		tileArray.forEach(tile => {			tile.tint();		});		//If no wilds are tinting, continue to pop		if(Match3Tile.tinting === 0) {			msgBus.publish("Game0.allTintsFinished");		}	}	//Once any wild icons are filled, recount pops and pop them	function onAllTintsFinished() {		console.log("onAllTintsFinished --------------"); //DEBUG		//re-count matches		tileArray.forEach(tile => {			tile.popCount();		});		//Pop icons		tileArray.forEach(tile => {			tile.pop();		});        		//Check if the sequence is complete		if(Match3Tile.popping === 0) {			//wait for animations to complete			console.log("TurnComplete ----------------"); //DEBUG			msgBus.publish("Game0.turnComplete");		}	}	//When icons have stopped popping, drop in new ones from the topRow	function onAllPopsFinished() {		console.log("AllPopsFinished --------------"); //DEBUG		tileDropArray = [];		Match3Tile.swapped = [];		for(let i = 0; i < config[currentBoard].bottomRow.length; i++) {			Match3Tile.tiles[config[currentBoard].bottomRow[i]].drop(topRow[i]);		}	}	//Track which tiles have dropped recently for the edge case where a match-4 is made by falling tiles	function onDropFinished(data) {		tileDropArray.push(data.tile);	}	//JUICY LOOT SPECIFIC CODE	//Custom pop tween for jug and glass.	function onPopCustom(data) {		let wTile = data.tile;		if (wTile._tintFamily === "none") {			//Glass or jug popped without filling - e.g. by a line clear or cherry explosion			let popFrames = Match3Tile.getPopFrames(wTile.icon === "symbolGlass" ? "glassCrack" : "jugCrack");			wTile.iconSprite.textures = popFrames.map(frame => {				return PIXI.Texture.fromFrame(frame);			});			wTile.iconSprite.animationSpeed = config.ANIM_SPEED_POP;			wTile.iconSprite.loop = false;			console.log("Pop+ " + wTile.id + " ----------------"); //DEBUG			Match3Tile.popping++;			wTile.iconSprite.onComplete = function () {				msgBus.publish("Game0.popFinished", data);				data.tile.onPopFinished();				Match3Tile.popping--;				console.log("Pop- " + data.tile.id + " ----------------"); //DEBUG				if (Match3Tile.popping === 0) {					msgBus.publish("Game0.allPopsFinished");				}			}.bind(wTile);			wTile.iconSprite.gotoAndPlay(0);			audio.play("match3BreakGlass");		} else {			//Filled glass/jug pop			if (wTile.icon === "symbolJug") {				//If the icon is a jug, pop all unpopped icons in the same tintFamily				tileArray.filter(tile => tile._iconType !== "wild" && tile.equals(wTile.id) && tile._popX + tile._popY === 0).forEach(tile => tile.pop(true));				audio.play("match3BigMatch");			}			//Tween out the wild icon			Match3Tile.popping++;			console.log("Pop+ " + wTile.id + " ----------------"); //DEBUG			new Timeline({				useFrames: true,				onComplete: function () {					Match3Tile.popping--;					console.log("Pop- " + data.tile.id + " ----------------"); //DEBUG					msgBus.publish("Game0.popFinished", data);					data.tile.onPopFinished();					if (Match3Tile.popping === 0) {						msgBus.publish("Game0.allPopsFinished");					}					this.iconSprite.alpha = 1;					this.iconSprite.y = 0;				},				onCompleteScope: wTile			})				.to(wTile.iconSprite.scale, 5 / config.ANIM_SPEED_POP, {y: 0.5}, "0")				.to(wTile.iconSprite.scale, 3 / config.ANIM_SPEED_POP, {y: 1.5}, String(5 / config.ANIM_SPEED_POP))				.to(wTile.iconSprite.scale, 4 / config.ANIM_SPEED_POP, {y: 1}, String(8 / config.ANIM_SPEED_POP))				.to(wTile.iconSprite, 5 / config.ANIM_SPEED_POP, {y: 20}, "0")				.to(wTile.iconSprite, 7 / config.ANIM_SPEED_POP, {					y: -240,					alpha: 0				}, String(5 / config.ANIM_SPEED_POP));			if (audio.exists(config.audioPopLookup[this.icon])) {				audio.play(config.audioPopLookup[this.icon]);			} else {				audio.play(config.audioPopLookup["default"]);			}		}	}	//Custom pop functions	function onPopStarted(data) {		//Add effects		let glow = new PIXI.Sprite(PIXI.Texture.fromFrame("comboSelectionSquare"));		let burst = new PIXI.Sprite(PIXI.Texture.fromFrame("comboBurst"));		data.tile.addChildAt(glow, data.tile.iconSprite);		data.tile.addChildAt(burst, data.tile.iconSprite);		new Timeline({			useFrames: true,			onComplete: function() {				this.removeChild(glow);				this.removeChild(burst);			},			onCompleteScope: data.tile		})			.fromTo(glow, 4 / config.ANIM_SPEED_POP, {alpha: 0}, {alpha: 1}, "0")			.fromTo(glow.scale, 4 / config.ANIM_SPEED_POP, {x: 0.7, y: 0.7}, {x: 1, y: 1}, "0")			.fromTo(burst, 4 / config.ANIM_SPEED_POP, {alpha: 0}, {alpha: 1}, "0")			.fromTo(burst, 14 / config.ANIM_SPEED_POP, {rotation: 0}, {rotation: 30}, "0")			.fromTo(burst.scale, 4 / config.ANIM_SPEED_POP, {x: 0.7, y: 0.7}, {x: 1, y: 1}, "0")			.to(glow, 4 / config.ANIM_SPEED_POP, {alpha: 0}, String(10 / config.ANIM_SPEED_POP))			.to(glow.scale, 4 / config.ANIM_SPEED_POP, {x: 0, y: 0}, String(10 / config.ANIM_SPEED_POP))			.to(burst, 4 / config.ANIM_SPEED_POP, {alpha: 0}, String(10 / config.ANIM_SPEED_POP))			.to(burst.scale, 4 / config.ANIM_SPEED_POP, {x: 0, y: 0}, String(10 / config.ANIM_SPEED_POP));		//Detect and spawn special icons on match-4, match-5		let vertical = data.tile._popX < data.tile._popY;		if(data.popVal === 4) {			//Match 5. Spawn a cherry bomb			data.tile.popSpawn("cherryBombAnim");		} else if(data.popVal === 3) {			//Tile is a key part of a match-4. This is a bit harder to resolve            let neighbourTiles = data.tile[vertical ? "_neighboursY" : "_neighboursX"].map(nID => {return Match3Tile.tiles[nID];});            if(neighbourTiles.some(nTile => {return nTile[vertical ? "_popY" : "_popX"] === 4;})) {                //spawn nothing, this is part of a match 5            } else if(Match3Tile.swapped.includes(data.tile)) {                //spawn stripeys where the tiles were swapped in                data.tile.popSpawn(getStripey(data.family, vertical));            } else if(tileDropArray.includes(data.tile)) {                //tile dropped into place				let droppedNeighbour;				for(let i = 0; i < neighbourTiles.length; i++) {					if(tileDropArray.includes(neighbourTiles[i]) && neighbourTiles[i][vertical ? "_popY" : "_popX"] === 3) {						droppedNeighbour = neighbourTiles[i];					}				}				if(!Match3Tile.swapped.includes(droppedNeighbour)) {					if(!droppedNeighbour) {						//This is the only key tile that dropped into place, so spawn a stripey.						data.tile.popSpawn(getStripey(data.family, vertical));					} else {						//Both key tiles dropped in, so spawn a stripey if this tile has the lowest index						if(droppedNeighbour.index > data.tile.index) {							data.tile.popSpawn(getStripey(data.family, vertical));						}					}				}            }		}		//Pop stripeys		let up, down, left, right, beamContainer;		let tilePos = data.tile.getGlobalPosition();		let upDown = (crossSwapTile === data.tile || data.icon.includes("Vertical"));		let leftRight = (crossSwapTile === data.tile || data.icon.includes("Horizontal"));		if(leftRight || upDown) {			up = upDown ? data.tile.allNeighboursToPoint(tilePos.x, 0) : [];			down = upDown ? data.tile.allNeighboursToPoint(tilePos.x, 10000) : [];			left = leftRight ? data.tile.allNeighboursToPoint(0, tilePos.y) : [];			right = leftRight ? data.tile.allNeighboursToPoint(10000, tilePos.y) : [];			beamContainer = new PIXI.Container();			displayList.particleLayer.addChild(beamContainer);			if(up.length) {				up.forEach(id =>  Match3Tile.tiles[id].pop(true));				spawnBeam(beamContainer, tilePos, Match3Tile.tiles[up[0]].getGlobalPosition());			} else if (down.length) {				spawnBeamSegment(beamContainer, tilePos.x, tilePos.y, "top");			}			if(down.length) {				down.forEach(id =>  Match3Tile.tiles[id].pop(true));				spawnBeam(beamContainer, tilePos, Match3Tile.tiles[down[down.length - 1]].getGlobalPosition());			} else if(up.length) {				spawnBeamSegment(beamContainer, tilePos.x, tilePos.y, "bottom");			}			if(left.length) {				left.forEach(id =>  Match3Tile.tiles[id].pop(true));				spawnBeam(beamContainer, tilePos, Match3Tile.tiles[left[0]].getGlobalPosition());			} else if(right.length) {				spawnBeamSegment(beamContainer, tilePos.x, tilePos.y, "left");			}			if(right.length) {				right.forEach(id =>  Match3Tile.tiles[id].pop(true));				spawnBeam(beamContainer, tilePos, Match3Tile.tiles[right[right.length - 1]].getGlobalPosition());			} else if(left.length) {				spawnBeamSegment(beamContainer, tilePos.x, tilePos.y, "right");			}			let middleSegment = "none";			if(up.length && down.length) {				middleSegment = left.length ? (right.length ? "all" : "leftTopBottom") : (right.length ? "rightTopBottom" : "none");			} else if (up.length) {				middleSegment = left.length ? (right.length ? "leftRightTop" : "leftTop") : (right.length ? "rightTop" : "none");			} else if (down.length) {				middleSegment = left.length ? (right.length ? "leftRightBottom" : "leftBottom") : (right.length ? "rightBottom" : "none");			}			if(middleSegment !== "none") {				spawnBeamSegment(beamContainer, tilePos.x, tilePos.y, middleSegment);			}		}		if(beamContainer) {			beamContainer.cacheAsBitmap = true;			new Timeline({				onComplete: function (container){					displayList.particleLayer.removeChild(container);				},				onCompleteParams: [beamContainer]			})				.fromTo(beamContainer, config.LINE_CLEAR_TIME * 0.1, {alpha: 0}, {alpha: 1, ease: "Linear.easeNone"}, "0")				.to(beamContainer, config.LINE_CLEAR_TIME * 0.9, {alpha: 0, ease: "Linear.easeNone"});			audio.play("match3LineClear");		}				//Pop cherry (lol)		if(data.icon.includes("cherry")) {            data.tile._neighboursX.forEach(id0 => {                Match3Tile.tiles[id0].pop(true);                Match3Tile.tiles[id0]._neighboursY.forEach(id1 => Match3Tile.tiles[id1].pop(true));            });            data.tile._neighboursY.forEach(id =>  Match3Tile.tiles[id].pop(true));		}	}	//Given an iconFamily, returns the horizontal or vertical stripey icon in the same family	function getStripey(iconFamily, vertical) {		return config.lineClearIcons[iconFamily][vertical ? 1 : 0];	}        //Creates a beam sprite and adds it to the container    function spawnBeamSegment(container, x, y, type, rotation, scaleX, scaleY) {        let beamSprite = new PIXI.Sprite(PIXI.Texture.fromFrame(config.lineClearBeams[type]));		beamSprite.x = x;		beamSprite.y = y;		beamSprite.rotation = rotation || 0;		beamSprite.scale.x = scaleX || 1;		beamSprite.scale.y = scaleY || 1;        container.addChild(beamSprite);    }	function spawnBeam(container, p1, p2) {		let lineLength = maths.pointDistance(p1, p2);		let linePos = lineLength;		let lineAngle = maths.pointAngle(p1, p2);		let beamLength = PIXI.Texture.fromFrame(config.lineClearBeams["middleH"]).width;		let beamEndLength = PIXI.Texture.fromFrame(config.lineClearBeams["right"]).width;				//spawn end of beam at p2		spawnBeamSegment(container, p2.x, p2.y, "right", lineAngle);		linePos -= beamEndLength / 2;		//spawn beam segments down the rest of the line		let totalSegments = Math.ceil(linePos / beamLength);		let lineScale = linePos / (totalSegments * beamLength); //scale down segments so a whole number of them fits the beam		beamLength *= lineScale;		linePos -= beamLength / 2; //beam segments are anchored at the centre		for(let i = 0; i < totalSegments; i++) {			let segPos = maths.lerp(p1, p2, (linePos / lineLength));			spawnBeamSegment(container, segPos.x, segPos.y, "middleH", lineAngle, lineScale);			linePos -= beamLength;		}	}	//END JUICY LOOT SPECIFIC CODE	//Disable/enable	//Disable tiles on request	function disableTiles() {		Match3Tile.deSelect();		tileArray.forEach(tile => {tile.interactive = false;});	}	//re-enable tiles on request (provided there are moves remaining)	function reEnableTiles() {		Match3Tile.deSelect();		if(gameState.moves > 0) {			tileArray.forEach(tile => {tile.interactive = true;});		}	}	//Start idle tweens at game0 start	function onStarted() {		enableIdle();		reEnableTiles();	}	//Handle game end	function onFinish() {		promFinish();		disableIdle();		disableTiles();	}    return {        init,		createBoard,		promptHint,		promptSparkle,        enable,        reset,		spawnBeam,		spawnBeamSegment    };});