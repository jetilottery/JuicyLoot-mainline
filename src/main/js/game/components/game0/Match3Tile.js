define((require) => {	const msgBus = require("skbJet/component/gameMsgBus/GameMsgBus");	const PIXI = require("com/pixijs/pixi");	const Pressable = require("skbJet/componentManchester/standardIW/components/pressable");	const filterStyles = require("game/template/filterStyles");	const audio = require("skbJet/componentManchester/standardIW/audio");	const config = require("skbJet/componentManchester/standardIW/gameConfig");	const utils = require("skbJet/componentManchester/standardIW/layout/utils");	const maths = require("skbJet/componentLondon/utils/maths");	const app = require("skbJet/componentManchester/standardIW/app");	const autoPlay =  require("game/altAutoPlay");	const pressable = require("skbJet/componentManchester/standardIW/components/pressable");	require("com/gsap/TweenMax");	require("com/gsap/TimelineLite");	const Tween = window.TweenMax;	const Timeline = window.TimelineLite;	let count = 0;	class Match3Tile extends Pressable {		//STATIC functions		//Returns the config data for a specific icon frame name.		// Returns undefined if the icon can't be found		static iconData(icon) {			if(!icon) {				return;			}			let family, type;			let name = icon.replace(/\d*$/, ""); //strip digits off the end			let keys = Object.keys(config.iconFamilies);			for(let k = 0; k < keys.length; k++) {				if(config.iconFamilies[keys[k]].includes(name)) {					family = keys[k];					let subKeys = Object.keys(config.iconTypes);					for(let s = 0; s < subKeys.length; s++) {						if(config.iconTypes[subKeys[s]].includes(family)) {							type = subKeys[s];							return {name: name, family: family, type: type};						}					}				}			}		}		//Convert config.iconOdds to a format more usable for weighted random picks		static calculateOdds() {			let ret = {				default: [],				baseOnly: [],				lowSwaps: []			};			let totalChance ;			let incChance;			let baseIcons = Match3Tile.iconKeys.filter(key => {				let data = Match3Tile.iconData(key);				return config.iconTypes.base.includes(data.family);			});			//default			totalChance = 0;			incChance = 0;			Match3Tile.iconKeys.forEach(key => { totalChance += config.iconOdds[key]; });			Match3Tile.iconKeys.forEach(key => {				incChance += config.iconOdds[key] / totalChance;				ret.default.push(incChance);			});			//baseOnly			totalChance = 0;			incChance = 0;			baseIcons.forEach(key => { totalChance += config.iconOdds[key]; });			baseIcons.forEach(key => {				incChance += config.iconOdds[key] / totalChance;				ret.baseOnly.push(incChance);			});			//lowSwaps			totalChance = 0;			incChance = 0;			Match3Tile.iconKeys.forEach(key => { totalChance += config.iconOddsLowSwaps[key]; });			Match3Tile.iconKeys.forEach(key => {				incChance += config.iconOddsLowSwaps[key] / totalChance;				ret.lowSwaps.push(incChance);			});			return ret;		}		static save() {			let keys = Object.keys(Match3Tile.tiles);			let ret = [];			keys.forEach(key => { ret.push({key: key, icon: Match3Tile.tiles[key].icon}); });			return ret;		}		static load(iconList) {			iconList.forEach(item => { Match3Tile.tiles[item.key].icon = item.icon; });		}		static loadPreviousTurn() {			let lastSeed = Match3Tile.logSeed.shift();			let lastBoard = Match3Tile.logBoard.shift();			Match3Tile.logSeed.push(lastSeed);			Match3Tile.logBoard.push(lastBoard);			maths.setSeed(lastSeed);			Match3Tile.load(lastBoard);		}		//Selects a tile to swap		static select(tile) {			Match3Tile.deSelect();			Match3Tile.active = tile;			Match3Tile.active.background.tint = 0xFF00FF;			audio.play("match3Select");		}		//Deselects selected tile		static deSelect() {			if(Match3Tile.active) {				Match3Tile.active.background.tint = 0xFFFFFF;				Match3Tile.active = undefined;			}			pressable._lock = null; //Force unlock of active tiles on deselect		}		//Creates a new tile in the container specified and adds it to the screen		static fromContainer(bgContainer, container) {			let tileConfig = config.tileConfig[container.name];			//Create tile			const tile = new Match3Tile(tileConfig.nX, tileConfig.nY, tileConfig.a ? tileConfig.a : tileConfig.nY[0]);//"above" property(used for tile drops only - not swaps) is set to first yNeighbour if not specified			//Add tile sprites to correct layers			//background is added behind the tile containers, at the same coordinates			bgContainer.addChildAt(tile.background, 0);			tile.background.position.set(container.x, container.y);			//icons and idleSprites are added to the tile proper			tile.addChild(tile.iconSprite);			tile.addChild(tile.idleSprite);			container.addChild(tile);			tile.id = container.name;			tile.index = Match3Tile.totalTiles;			Match3Tile.tiles[tile.id] = tile;			tile.background.scale.set(0);			tile.scale.set(0);			return tile;		}		//Removes a tile from its containers and the static tile reference object		static remove(tile) {			if(tile.background.parent !== null) {				tile.background.parent.removeChild(tile.background);			}			if(tile.parent !== null) {				tile.parent.removeChild(tile);			}			delete Match3Tile.tiles[tile.id];			tile.destroy();		}		//DEBUG		static debugArrow(g, p1, p2) {			let dX = (p2.x - p1.x) - Math.sign(p2.x - p1.x) * 100;			let dY = (p2.y - p1.y) - Math.sign(p2.y - p1.y) * 100;			let arrowHead = new PIXI.Sprite(PIXI.Texture.fromFrame("debugArrowHead"));			arrowHead.rotation = maths.pointAngle(p1, p2);			arrowHead.position.set(p1.x + dX, p1.y + dY);			g.lineColor = 0xE31FDB;			g.lineAlpha = 1;			g.lineWidth = 16;			g.moveTo(p1.x, p1.y);			g.lineTo(p1.x + dX, p1.y + dY);			g.addChild(arrowHead);		}		static debug(options) {			options = options || {};			let keys = Object.keys(Match3Tile.tiles);			if(!Match3Tile.DEBUG && !Match3Tile.DEBUGREADY) {				keys.forEach(key => {					Match3Tile.tiles[key]._debugID = new PIXI.Text(Match3Tile.tiles[key].id, {fontSize: 30, dropShadow: true, fill: "white"});					Match3Tile.tiles[key]._debugID.position.set(-50, -55);					Match3Tile.tiles[key].addChild(Match3Tile.tiles[key]._debugID);					Match3Tile.tiles[key]._debugPopX = new PIXI.Text("X: " + Match3Tile.tiles[key]._popX, {fontSize: 40, dropShadow: true, fill: "cyan"});					Match3Tile.tiles[key]._debugPopY = new PIXI.Text("Y: " + Match3Tile.tiles[key]._popY, {fontSize: 40, dropShadow: true, fill: "cyan"});					Match3Tile.tiles[key]._debugDirty = new PIXI.Text("D", {fontSize: 50, dropShadow: true, fill: Match3Tile.tiles[key]._dirty ? "red" : "black"});					Match3Tile.tiles[key]._debugPopX.position.set(-61, -30);					Match3Tile.tiles[key]._debugPopY.position.set(-58, 8);					Match3Tile.tiles[key]._debugDirty.position.set(17, -14);					Match3Tile.tiles[key]._debugPopX.visible = false;					Match3Tile.tiles[key]._debugPopY.visible = false;					Match3Tile.tiles[key]._debugDirty.visible = false;					Match3Tile.tiles[key].addChild(Match3Tile.tiles[key]._debugPopX);					Match3Tile.tiles[key].addChild(Match3Tile.tiles[key]._debugPopY);					Match3Tile.tiles[key].addChild(Match3Tile.tiles[key]._debugDirty);				});				Match3Tile._debugNeighbours = new PIXI.Container();				app.stage.addChild(Match3Tile._debugNeighbours);				let g = new PIXI.Graphics();				keys.forEach(key => {					let tile = Match3Tile.tiles[key];					tile._neighboursX.concat(tile._neighboursY).forEach(nID => {						Match3Tile.debugArrow(g, tile.getGlobalPosition(), Match3Tile.tiles[nID].getGlobalPosition());					});				});				Match3Tile._debugNeighbours.addChild(g);				Match3Tile._debugNeighbours.visible = false;				//Match3Tile.logBoard = [Match3Tile.save(), undefined, undefined, undefined, undefined];				//Match3Tile.logSwap = [Match3Tile.swapped[0].id + "," + Match3Tile.swapped[1].id, undefined, undefined, undefined, undefined];				Match3Tile.DEBUG = true;				Match3Tile.DEBUGREADY = true;			}			if(options["dirty"] !== undefined) {				keys.forEach(key => {					Match3Tile.tiles[key]._debugDirty.visible = options["dirty"];					Match3Tile.dirty(Match3Tile.tiles[key]);				});			}			if(options["pop"] !== undefined) {				keys.forEach(key => {					Match3Tile.tiles[key]._debugPopX.visible = options["pop"];					Match3Tile.tiles[key]._debugPopY.visible = options["pop"];				});			}			if(options["id"] !== undefined) {				keys.forEach(key => {					Match3Tile.tiles[key]._debugID.visible = options["id"];				});			}			if(options["neighbours"] !== undefined) {				Match3Tile._debugNeighbours.visible = options["neighbours"];			}		}		//Gets the explode frames for the icon name provided		static getPopFrames(icon) {			if(!Match3Tile.popFrames[icon]) {				Match3Tile.popFrames[icon] = utils.findFrameSequence(icon);			}			return Match3Tile.popFrames[icon];		}		//Selects a random key from the icon list based on the fill chances in config		static pickIcon(iconSet) {			let pick = maths.random();			iconSet = iconSet || "default";			let i = 0;			while ((typeof Match3Tile.iconChances[iconSet][i] !== "undefined") && Match3Tile.iconChances[iconSet][i] <= pick) {				i++;			}			//Check for three-in-a-row of the same icon			if(				(Match3Tile.pickBuffer[0] !== Match3Tile.iconKeys[i] && Match3Tile.pickBuffer[1] !== Match3Tile.iconKeys[i])				||				iconSet === "lowSwaps"			) {				Match3Tile.pickBuffer.unshift(Match3Tile.iconKeys[i]);				Match3Tile.pickBuffer.pop();				return Match3Tile.iconKeys[i];			} else {				return Match3Tile.pickIcon(iconSet);			}		}		static get allSwaps() {			//if(Match3Tile._dirty) {				Match3Tile._allSwaps = Match3Tile.findAllSwaps(true);				Match3Tile._dirty = false;			//}			return Match3Tile._allSwaps;		}		static get resolving() {			return Match3Tile.swapping || Match3Tile.popping || Match3Tile.dropping || Match3Tile.tinting;		}		//Tests all tiles for available swaps and returns a flat array of all them		static findAllSwaps(force) {			if(Match3Tile.DEBUG_NOSWAPS) {				count++;				if(!(count % 3)) {					return [];				}			}			let allSwaps = [];			Object.keys(Match3Tile.tiles).forEach(key => {				let tile = Match3Tile.tiles[key];				let swaps = tile.swapFind(force);				swaps.forEach(swap => {					allSwaps.push({swap: [tile, Match3Tile.tiles[swap.withID]], score: swap.score});				});			});			if(Match3Tile.swapAlarm && allSwaps.length > config.HIGH_SWAPS) {				Match3Tile.swapAlarm = false;			}			if(allSwaps.length < config.LOW_SWAPS) {				Match3Tile.swapAlarm = true;			}			return allSwaps;		}		static findHint() {			//Don't even try to hint if autoplay is running.			if(autoPlay._enabled) {				return [];			}			//Return an empty array if in the middle of resolving a move			if(Match3Tile.swapping || Match3Tile.popping || Match3Tile.dropping || Match3Tile.tinting) {				return [];			}			//Return an empty array if there are no swaps. Note that you should never check allSwaps during a move			if(!Match3Tile.allSwaps.length) {				return [];			}			//Get the highest-scoring swap			let topScore = Match3Tile.allSwaps.reduce((acc, curr) => {				if(curr.score > acc.score) {					return curr;				}				return acc;			}, {score: 0}).score;						//We want to pick a value that's not the first available match-3, but keep it consistent with autoplay			let swaps = Match3Tile.allSwaps.filter(curr => curr.score === topScore);			let swap = swaps[Math.floor(swaps.length * 0.5)].swap; //Pick the one in the middle			//Find all the tiles in the sequence			//First determine which tile is which in the swap			let destination, source;			if(swap[0].swapTest(swap[1]) >= 2) {				destination = swap[0];				source = swap[1];			} else {				swap[1].swapTest(swap[0]); //Need to perform the test to calculate _popX / _popY				source = swap[1];				destination = swap[0];			}			//Now find the other tiles.			let v = destination._popY > destination._popX;			let neighbourSets = destination[v ? "_neighboursY" : "_neighboursX"].map(n => Match3Tile.tiles[n].allNeighboursOppositeTo(destination));			//swap source and destination's icons			[source.icon, destination.icon] = [destination.icon, source.icon];			//Get the popCount for each tile on the the column or row			neighbourSets.forEach(neighbourSet => neighbourSet.forEach(nID => Match3Tile.tiles[nID].popCount()));			//swap them back			[source.icon, destination.icon] = [destination.icon, source.icon];			//After calling popCount on the whole row/column only the values in the sequence will have popX/popY above 0,			// so it is relatively easy to cull the tiles from the neighbourSets that aren't part of the sequence			for(let i = 0; i < neighbourSets.length; i++) {				for(let j = 0; j < neighbourSets[i].length; j++) {					let tile = Match3Tile.tiles[neighbourSets[i][j]];					if(tile[v ? "_popY" : "_popX"] === 1) {						neighbourSets[i].splice(j + 1);						break;					} else if(tile[v ? "_popY" : "_popX"] === 0) {						neighbourSets[i].splice(j);						break;					}				}			}			// Return the tiles making the sequence as a single array			let flat = [];			neighbourSets.forEach(n => { flat = flat.concat(n); });			return flat.map(nID => Match3Tile.tiles[nID]).concat(source);		}		//Sets the dirty flag on a tile and all its neighbours		static dirty(tile) {			tile._dirty = true;			tile._neighboursX.concat(tile._neighboursY).forEach(neighbour => Match3Tile.tiles[neighbour]._dirty = true);			if(Match3Tile.DEBUG) {				tile._debugDirty.style.fill = "red";			}			Match3Tile._dirty = true;		}		//Initialise the static properties of Match3Tile. This is in a function as eslint doesn't like them being declared with the static functions.		static _initStaticProperties() {			if(Match3Tile._initialised) {				return;			}			Match3Tile.WIDTH = 126;		  	//px			Match3Tile.HEIGHT = 111;		//px			Match3Tile.DEBUG = false;		//debug			Match3Tile.DEBUG_NOSWAPS = false;			Match3Tile.logBoard = [undefined, undefined, undefined, undefined, undefined];			Match3Tile.logSwap = [undefined, undefined, undefined, undefined, undefined];			Match3Tile.logSeed = [undefined, undefined, undefined, undefined, undefined];			Match3Tile.tiles = Match3Tile.tiles || {};	//name:ref pairs for all current game tiles			Match3Tile.active = undefined;  //holds ref to currently selected tile (tile clicked on or being dragged)			Match3Tile.swapped = [];        //holds ref to the last tile to be successfully swapped (the tile the active tile swapped to)			Match3Tile.swapping = 0;		//only false/0 when no icons are swapping			Match3Tile.popping = 0;			//only false/0 when no icons are popping			Match3Tile.dropping = 0;		//only false/0 when no icons are dropping			Match3Tile.tinting = 0;			//only false/0 when no wild icons are tinting. I hate that i can't find a "swap" rhyme for this			Match3Tile.totalTiles = Match3Tile.totalTiles || 0; //Counts how many tiles currently exist			Match3Tile.iconKeys = Object.keys(config.iconOdds);	//Frame names/patterns for the tile sprites			Match3Tile.iconChances = Match3Tile.calculateOdds();		//Machine-useful tile odds from the config file			Match3Tile.dropSpeed = Match3Tile.HEIGHT / config.DROP_TIME; 	//Per-px speed for falling tiles			Match3Tile.pickBuffer = ["none", "none"];	//Stores the last icons to be dropped. Avoid dropping three of the same tile			Match3Tile.swapAlarm = false;	//Flips true if the available swaps goes below config.LOW_SWAPS			Match3Tile.popFrames = {};			Match3Tile._allSwaps = [];		//Private static. stores the list of available swaps			Match3Tile._dirty = true;		//True when swap data needs recalculated			Match3Tile._pointerDown = false;	//True while the pointer is down			Match3Tile._initialised = true;		}		//CONSTRUCTOR		constructor(neighboursX, neighboursY, above) {			super();			Match3Tile._initStaticProperties(); //eslint doesn't like static properties being declared outside of functions			// Neighbouring tiles			this._above = above;			 //Tile to drop-fill from (if any)			this._neighboursX = neighboursX; //Horizontal neighbours (can be swapped/matched)			this._neighboursY = neighboursY; //Vertical neighbours (can be swapped/matched)			//Spawn offset (used to add new icons)			this._spawnOffset = {x: 0, y: -Match3Tile.HEIGHT};			// Info to share with neighbours			this._icon = "none"; 		// icon frame			this._iconType = "none"; 	// icon type (base, wild, instant)			this._iconFamily = "none"; 	// icon family (e.g. "apple", "glass");			this._tintFamily = "none";	// icon family after wild icons have been tinted			this._dirty = true;			// true when icon has no useful swap data			this._swaps = [];			// stores possible swaps with neighbours. Populated by swapFind()			// Pop meters. 0 = no match. 1 = part of a 3 (not the middle). 2 = middle of 3. 3 = middle of 4. 4 = middle of 5.			this._popX = 0; // Indicates being part of a row of matching tiles.			this._popY = 0; // Indicates being part of a column of matching tiles.			this._popData = undefined; // Stores icon pop info during pop sequence			this._popComplete = this.popComplete; // Stores popComplete function somewhere that isn't hidden by firefox for some reason			this._popTriggered = false; // true from when an icon pops until a drop is complete			this._tintTriggered = false; // true from when a wild icon tints until a drop is complete			// Pop IconData. Set this to add a new icon as a result from a tile pop			this._popIcon = undefined;			this.popSprite = undefined;			// Create all the component sprites			this.background = new PIXI.Sprite(PIXI.Texture.fromFrame("SingleSymbolPanel"));			this.background.filters = [];			this.iconSprite = new PIXI.extras.AnimatedSprite([PIXI.Texture.EMPTY]);			this.idleSprite = new PIXI.Sprite(PIXI.Texture.fromFrame("symbolSparkle"));			// Center everything			this.background.anchor.set(0.5);			this.iconSprite.anchor.set(0.5);			this.idleSprite.anchor.set(0.5);			//Hide idleSprite			this.idleSprite.visible = false;			// Interactivity			this.hitArea = new PIXI.Rectangle(				Match3Tile.WIDTH / -2,				Match3Tile.HEIGHT / -2,				Match3Tile.WIDTH,				Match3Tile.HEIGHT			);			//Select an "active" tile on first press, then a tile to swap test on second press, OR on press & drag of a tile			this.moveLock = null;					//During pointermove, tile must "lock" to moving towards Xneighbours or yNeighbours.			this.on("pointerdown", this.onPointerDown);			this.on("pointerup", this.onPointerUp);			this.on("pointerupoutside", this.onPointerUp);			this.on("pointermove", this.onMove);			Match3Tile.totalTiles++;			this.reset();		}		onPointerUp(event) {			if(event.data.pointerType === 'mouse' && event.data.button !== 0) {				return; //left clicks only			}			Match3Tile._pointerDown = false;		}		onMove(event) {			if(autoPlay._enabled || !Match3Tile._pointerDown || Match3Tile.active !== this || Match3Tile.swapping + Match3Tile.tinting + Match3Tile.popping + Match3Tile.dropping > 0) { //No moving tiles during resolve phase				return;			}			let tilePos = Match3Tile.active.getGlobalPosition();			let fingerPos = event.data.global;			//get the nearest neighbour that the player is swiping in the direction of			let nearestNeighbour;			let nearestDist = 100000;			let horizDist = Math.abs(fingerPos.x - tilePos.x);			let vertDist = Math.abs(fingerPos.y - tilePos.y);			let horiz = horizDist > vertDist;			//escape if the swipe is too small			if((horiz ? horizDist : vertDist) < config.SWIPE_DEAD_ZONE) {				return;			}			//Find the nearest neighbour to the touch event			(horiz ? this._neighboursX : this._neighboursY).forEach(nID => {				let neighbourDist = maths.pointDistance(tilePos, Match3Tile.tiles[nID].getGlobalPosition()); //distance between tiles				let fingerDist = maths.pointDistance(fingerPos, Match3Tile.tiles[nID].getGlobalPosition()); //distance between neighbour and finger				if(fingerDist < neighbourDist && fingerDist < nearestDist) {					nearestDist = fingerDist;					nearestNeighbour = Match3Tile.tiles[nID];				}			});			//If any neigbours exist, swap			if(nearestNeighbour) {				Match3Tile.active.swap(nearestNeighbour);			}		}		onPointerDown(event) {			if(event.data.pointerType === 'mouse' && event.data.button !== 0) {				return; //left clicks only			}			if(autoPlay._enabled || Match3Tile.swapping + Match3Tile.tinting + Match3Tile.popping + Match3Tile.dropping > 0) { //No moving tiles during resolve phase				return;			}			Match3Tile._pointerDown = true;			if(Match3Tile.active) {				if(Match3Tile.active === this) {					return; //Tapping the same tile twice doesn't deselect it				}				//Only allow swaps between tiles that are neighbours				if(this._neighboursX.concat(this._neighboursY).includes(Match3Tile.active.id)) {					this.swap(Match3Tile.active);				} else {					Match3Tile.select(this);				}			} else {				Match3Tile.select(this);			}		}		//Idle animation trigger		showSparkle() {			//Spawn the sparkle at a random point on the fruit			this.idleSprite.position.set(				(Math.random() * this.iconSprite.width - this.iconSprite.width / 2) * 0.9,				(Math.random() * this.iconSprite.height - this.iconSprite.height / 2) * 0.9			);			Tween.fromTo(this.idleSprite, config.SPARKLE_TIME, {pixi: {rotation: 0}}, {pixi: {rotation: 360}, ease: "Linear.easeNone"});			Tween.fromTo(this.idleSprite, config.SPARKLE_TIME / 2, {alpha: 0, visible: false}, {alpha: 1, visible: true, ease: "Power4.easeOut", repeat: 1, yoyo: true});		}		//Hint animation trigger		showHint() {			this.background.filters = [filterStyles.hint];		}		hideHint() {			this.background.filters = [];		}		disable() {			this.enabled = false;		}		reset() {			this.enabled = false;			this._icon = "none";			this._iconType = "none";			this._iconFamily = "none";			this._tintFamily = "none";		}		//SWAP		//test if switching a tile's icon with another will result in a match		swapTest(other) {			//Test for icon pairs (icons that always swap with each other)			if(config.iconPairs.includes(this.icon) && config.iconPairs.includes(other.icon)) {				return true;			}			//just switch icons, count pops, then switch back			[this.icon, other.icon] = [other.icon, this.icon];			let retVal = this.popCount();			[this.icon, other.icon] = [other.icon, this.icon];			return retVal;		}		//Checks if this tile can be swapped with a neighbour to get a match and returns the tile(s) that can/can't be swapped		swapFind(force) {			if(this._dirty || force) {				if(this._iconType === "instant") {					return this._neighboursX.concat(this._neighboursY).map(nID => {						return {withID: nID, score: 0};					});				}				this._swaps = [];				this._neighboursX.concat(this._neighboursY).forEach(nID => {					let swapScore = this.swapTest(Match3Tile.tiles[nID]);					if(swapScore > 0) {						this._swaps.push({withID: nID, score: swapScore});					}				});				this._dirty = false;				if(Match3Tile.DEBUG) {					this._debugDirty.style.fill = "black";				}			}			return this._swaps;		}		//Attempt to swap icon with a neighbouring tile		swap(other) {			if(Match3Tile.swapping) {				return; //It appears that GSAP occasionally fires callbacks twice			}			Match3Tile.swapping++;			let dX = (other.parent.x - this.parent.x);			let dY = (other.parent.y - this.parent.y);			let swappedInstant = (Match3Tile.active === this || Match3Tile.active === other) && (other._iconType === "instant" || this._iconType === "instant");			if(swappedInstant || (this.swapTest(other) || other.swapTest(this))) {				//Complete the swap				Match3Tile.swapped = [this, other];				Match3Tile.logBoard.unshift(Match3Tile.save());				Match3Tile.logBoard.pop();				Match3Tile.logSwap.unshift(Match3Tile.swapped[0].id + "," + Match3Tile.swapped[1].id);				Match3Tile.logSwap.pop();				Match3Tile.logSeed.unshift(maths.getSeed());				Match3Tile.logSeed.pop();				let sqScaleX = 1, sqScaleY = 1, sqDX = 0, sqDY = 0, oSqDX = 0, oSqDY = 0;				if(Math.abs(dX) > 1) {					sqScaleX = config.SQUISH_MIN;					sqDX = Math.sign(dX) * (1 - config.SQUISH_MIN) * this.iconSprite.width;					oSqDX = Math.sign(dX) * (1 - config.SQUISH_MIN) * other.iconSprite.width;				}				if(Math.abs(dY) > 1) {					sqScaleY = config.SQUISH_MIN;					sqDY = Math.sign(dY) * (1 - config.SQUISH_MIN) * this.iconSprite.height;					oSqDY = Math.sign(dY) * (1 - config.SQUISH_MIN) * other.iconSprite.height;				}				audio.play("match3Swap");				msgBus.publish("Game0.swapStarted", {source: this, destination: other});				new Timeline({onComplete: () => {					[this.icon, other.icon] = [other.icon, this.icon];					this.iconSprite.x = 0;					this.iconSprite.y = 0;					this.iconSprite.scale.set(1);					other.iconSprite.x = 0;					other.iconSprite.y = 0;					other.iconSprite.scale.set(1);					Match3Tile.swapping--;					Match3Tile.dirty(this);					Match3Tile.dirty(other);					if(Match3Tile.swapping === 0) {						msgBus.publish("Game0.removeMove"); //Decrement the move counter						msgBus.publish("Game0.swapFinished", {source: this, destination: other}); //Pass the swapped tile (used by instants)					}				}})					.to(this.iconSprite, config.SWAP_TIME - (config.SQUISH_TIME / 2), {ease: "Linear.easeNone", x: dX + sqDX, y: dY + sqDY}, 0)					.to(other.iconSprite, config.SWAP_TIME - (config.SQUISH_TIME / 2), {ease: "Linear.easeNone", x: -dX - oSqDX, y: -dY - oSqDY}, 0)					.to(this.iconSprite,  config.SQUISH_TIME / 2, {ease: "Linear.easeNone", pixi: {scaleX: sqScaleX, scaleY: sqScaleY}}, config.SWAP_TIME - config.SQUISH_TIME)					.to(other.iconSprite, config.SQUISH_TIME / 2, {ease: "Linear.easeNone", pixi: {scaleX: sqScaleX, scaleY: sqScaleY}}, config.SWAP_TIME - config.SQUISH_TIME)					.to(this.iconSprite, config.SQUISH_TIME / 2, {ease: "Linear.easeNone", x: dX, y: dY, pixi: {scaleX: 1, scaleY: 1}}, config.SWAP_TIME  - (config.SQUISH_TIME / 2))					.to(other.iconSprite, config.SQUISH_TIME / 2, {ease: "Linear.easeNone", x: -dX, y: -dY, pixi: {scaleX: 1, scaleY: 1}}, config.SWAP_TIME - (config.SQUISH_TIME / 2));			} else {				//Half-swap, then send the icons back				new Timeline({onComplete: () => {					this.iconSprite.x = 0;					this.iconSprite.y = 0;					other.iconSprite.x = 0;					other.iconSprite.y = 0;					Match3Tile.swapping--;					msgBus.publish("Game0.swapFail"); //Trigger turnComplete alarm on autoplay				}})					.to(this.iconSprite, config.SWAP_TIME / 2, {ease: "Linear.easeNone", x: dX / 2, y: dY / 2}, "0")					.to(other.iconSprite, config.SWAP_TIME / 2, {ease: "Linear.easeNone", x: -dX / 2, y: -dY / 2}, "0")					.to(this.iconSprite, config.SWAP_TIME / 2, {ease: "Linear.easeNone", x: 0, y: 0}, "reverseLabel")					.to(other.iconSprite, config.SWAP_TIME / 2, {ease: "Linear.easeNone", x: 0, y: 0}, "reverseLabel");			}			//Deselect active tile on attempt, it looks nicer			Match3Tile.deSelect();		}		//TINT		//Run a "tint" animation to turn a wild icon to an icon of the correct colour.		tint() {			if(this._tintTriggered || this._tintFamily !== "none" || this._iconType !== "wild" || (this._popX + this._popY === 0)) {				return;			}			//find the highest-scoring combination to join			if(this._popX > this._popY) {				this._tintFamily = Match3Tile.tiles[this._neighboursX.reduce((acc, elem) => Match3Tile.tiles[elem]._popX > Match3Tile.tiles[acc]._popX ? elem : acc)]._tintFamily;			} else {				this._tintFamily = Match3Tile.tiles[this._neighboursY.reduce((acc, elem) => Match3Tile.tiles[elem]._popY > Match3Tile.tiles[acc]._popY ? elem : acc)]._tintFamily;			}			msgBus.publish("Game0.tintStarted", {tile: this}); //Handle wild tile behaviour in match3Board.js			//re-test any un-tinted wild tiles (for edge cases where two untinted wilds are in the same combination)			for(let id in Match3Tile.tiles) {				Match3Tile.tiles[id].popCount();				Match3Tile.tiles[id].tint();			}			//Start tint animation if available			if(config.tintFrames[this._iconFamily] && config.tintFrames[this._iconFamily][this._tintFamily]) {				this._tintTriggered = true;				let popFrames = Match3Tile.getPopFrames(config.tintFrames[this._iconFamily][this._tintFamily]);				this._iconType = "base";				this.iconSprite.textures = popFrames.map(frame => {	return PIXI.Texture.fromFrame(frame); });				this.iconSprite.loop = false;				Match3Tile.tinting++;				this.iconSprite.onComplete = function () {					Match3Tile.tinting--;					msgBus.publish("Game0.tintFinished", {tile: this});					if (Match3Tile.tinting === 0) {						msgBus.publish("Game0.allTintsFinished");					}				}.bind(this);				this.iconSprite.gotoAndPlay(0);				if(audio.exists(config.audioTintLookup[this.icon])) {					audio.play(config.audioTintLookup[this.icon]);				} else if(audio.exists(config.audioTintLookup["default"])) {					audio.play(config.audioTintLookup["default"]);				}			}		}		//POP		//Test tile to see if its icon should pop. Saves popX, popY values to indicate the tile's position in the sequence of 3, 4 or 5 tiles.		//Returns number of pops in both directions combined (i.e. true/false)		//Example _popX/_popY values:		// Match 3: (1) - (2) - (1)		// Match 4: (1) - (3) - (3) - (1)		// Match 5: (1) - (3) - (5) - (3) - (1)		popCount() {			this._popX = 0;			this._popY = 0;			if(Match3Tile.swapped.includes(this) && this._iconType === "instant") {				this._popX = 1;				this._popY = 1;				return 2;			}			//First test for tiles at the end of a 3			try {				this._neighboursX.forEach(nX => {					let opp = Match3Tile.tiles[nX].neighbourOppositeTo(this);					if(this.equals(nX) && this.equals(opp) && Match3Tile.tiles[opp].equals(nX)) {						this._popX += 1;					}				});				this._neighboursY.forEach(nY => {					let opp = Match3Tile.tiles[nY].neighbourOppositeTo(this);					if(this.equals(nY) && this.equals(opp) && Match3Tile.tiles[opp].equals(nY)) {						this._popY += 1;					}				});			} catch (error) {				console.error(error);			}			//Next test for tiles in the middle of a 3			if(				this._neighboursX.length > 1 &&				this.equals(this._neighboursX[0]) &&				this.equals(this._neighboursX[1]) &&				Match3Tile.tiles[this._neighboursX[0]].equals(this._neighboursX[1])			) {				this._popX += 2;			}			if(				this._neighboursY.length > 1 &&				this.equals(this._neighboursY[0]) &&				this.equals(this._neighboursY[1]) &&				Match3Tile.tiles[this._neighboursY[0]].equals(this._neighboursY[1])			) {				this._popY += 2;			}			//DEBUG			if(Match3Tile.DEBUG) {				this._debugPopX.text = this._popX ? "X: " + this._popX : "";				this._debugPopY.text = this._popY ? "Y: " + this._popY : "";				this._debugPopX.visible = true;				this._debugPopY.visible = true;			}			return this._popX + this._popY;		}		//Explode icons. Send message to indicate scoring		//set force=true to pop icons with zero _popX or _popY values		pop(force) {			if(!this._popTriggered && (force || (this._popX + this._popY > 0))) {				this._popTriggered = true;				this._popData = {tile: this, popVal: this.popVal, icon: this.icon.valueOf(), type: this._iconType.valueOf(), family: this._tintFamily.valueOf()};				msgBus.publish("Game0.popStarted", this._popData); //Send the icon data as it may change				Match3Tile.dirty(this);				//Use popFrames from config if available. Otherwise, just publish the popCustom signal				if(config.explodeFrames[this._iconFamily]) {					let popFrames = Match3Tile.getPopFrames(config.explodeFrames[this._iconFamily]);					this.iconSprite.textures = popFrames.map(frame => {return PIXI.Texture.fromFrame(frame);});					this.iconSprite.animationSpeed = config.ANIM_SPEED_POP;					this.iconSprite.loop = false;					Match3Tile.popping++;					console.log("Pop+ " + this.id + " ----------------"); //DEBUG					this.iconSprite.onComplete = (tile => {						return function() { tile.popComplete(); };					})(this);					if(this.iconSprite.totalFrames <= 1) {						console.log("-----  FRAME FAIL!  -----");						console.log("icon: " + this._icon);						console.log("iconFamily: " + this._iconFamily);						console.log("explodeFrames: " + config.explodeFrames[this._iconFamily]);						console.log("popFrames: " + popFrames);						console.log("popFrames re-get: " + Match3Tile.getPopFrames(config.explodeFrames[this._iconFamily]));					}					this.iconSprite.gotoAndPlay(0);					if(this._popIcon) {						if(audio.exists(config.audioSpawnLookup[this._popIcon])) {							audio.play(config.audioSpawnLookup[this._popIcon]);						} else {							audio.play(config.audioSpawnLookup["default"]);						}					} else {						if(audio.exists(config.audioPopLookup[this.icon])) {							audio.play(config.audioPopLookup[this.icon]);						} else {							audio.play(config.audioPopLookup["default"]);						}					}					//Play match sounds on tiles in the middle of a 3					if(this.popVal === 2) {						audio.playSequential("match3Match");					}				} else {					msgBus.publish("Game0.popCustom", this._popData);				}			}		}		popComplete() {			msgBus.publish("Game0.popFinished", this._popData);			this.onPopFinished();			Match3Tile.popping--;			console.log("Pop- " + this.id + " ----------------"); //DEBUG			if(Match3Tile.popping === 0) {				msgBus.publish("Game0.allPopsFinished");			}		}		//Change tile to one that won't pop. Returns whether or not the tile was unpopped		popUndo() {			let remainingTiles = this._neighboursX.concat(this._neighboursY);			//Try swapping with another tile			while(remainingTiles.length > 0) {				//Randomly select a neighbour to swap with				let [nextN] = remainingTiles.splice(Math.floor(maths.random() * remainingTiles.length), 1);				[this.icon, Match3Tile.tiles[nextN].icon] =	[Match3Tile.tiles[nextN].icon, this.icon];				if(this.popCount() < 2) {					//Swapped icon may be part of a match, but it is not a "key" part.					return true;				} else {					//Swapped icon is still a "key" part in a match					[this.icon, Match3Tile.tiles[nextN].icon] =	[Match3Tile.tiles[nextN].icon, this.icon];				}			}			//Try randomising a base tile using the correct odds (lets put a limit on this just in case)			let tilesTried = [];			for(let i = 0; i < config.MAX_UNPOP_TRIES; i++) {				this.icon = Match3Tile.pickIcon("baseOnly");				if(this.popCount() < 2) {					return true;				}				tilesTried.push(this.icon);			}		}		//Spawn a new sprite under the current icon that becomes the iconSprite on pop		popSpawn(icon) {			this._popIcon = icon;			let popFrames = Match3Tile.getPopFrames(icon);			this.popSprite = new PIXI.extras.AnimatedSprite(popFrames.map(frame => {return PIXI.Texture.fromFrame(frame);}));			this.popSprite.animationSpeed = config.ANIM_SPEED_ICON;			this.addChildAt(this.popSprite, this.getChildIndex(this.iconSprite));		}		onPopFinished() {			if(this._popIcon) {				this.icon = this._popIcon;				this._popIcon = undefined;				this.removeChild(this.popSprite);				this.popSprite = undefined;			} else {				this.icon = "none";			}			this._popTriggered = false;			this._tintTriggered = false;		}		//DROP		//Get the next available icon from the tiles above		dropGet(bottomTile, count) {			//console.log("dropGet: " + bottomTile.id); //debug, Good for finding bad layouts			this._spawnOffset = bottomTile._spawnOffset; //Just pass this ref up the chain.			if(this._icon === "none") {				//Request another icon from above				Match3Tile.dirty(this);				if(this._above === "top") {					this.dropFinish(bottomTile, ++count);				} else {					Match3Tile.tiles[this._above].dropGet(bottomTile, ++count);				}			} else if(count) {				//Drop this tile's icon to the bottom tile				//(actually we"re cloning the this tile's icon & position onto bottomTile's icon and dropping that)				Match3Tile.dirty(this);				bottomTile.icon = this.icon;				this.icon = "none";				let dX = (this.parent.x - bottomTile.parent.x);				let dY = (this.parent.y - bottomTile.parent.y);				let dT = maths.vec2Length(dX, dY) / Match3Tile.dropSpeed;				let sqScaleX = 1, sqScaleY = 1, sqDX = 0, sqDY = 0;				if(Math.abs(dX) > 1) {					sqScaleX = 1 - (config.SQUISH_MIN - ((config.SQUISH_MIN - config.SQUISH_MAX) * (Math.abs(dX) / config.gameBoardMax.width)));					sqDX = -Math.sign(dX) * (1 - sqScaleX) * bottomTile.iconSprite.width;				}				if(Math.abs(dY) > 1) {					sqScaleY = 1 - (config.SQUISH_MIN - ((config.SQUISH_MIN - config.SQUISH_MAX) * (Math.abs(dY) / config.gameBoardMax.height)));					sqDY = -Math.sign(dY) * (1 - sqScaleY) * bottomTile.iconSprite.height;				}				bottomTile.iconSprite.position.set(dX, dY);				msgBus.publish("Game0.dropStarted", {tile: bottomTile});				Match3Tile.dropping++;				new Timeline({					onComplete: (tile) => {						this.iconSprite.x = 0;						this.iconSprite.y = 0;						msgBus.publish("Game0.dropFinished", {tile: tile});						Match3Tile.dropping--;						if(Match3Tile.dropping === 0) {							msgBus.publish("Game0.allDropsFinished");						}					},					onCompleteParams: [bottomTile]				})					.to(bottomTile.iconSprite, dT - (config.SQUISH_TIME / 2), {ease: "Linear.easeNone", x: sqDX, y: sqDY})					.to(bottomTile.iconSprite, config.SQUISH_TIME / 2, {ease: "Linear.easeNone", pixi: {scaleX: sqScaleX, scaleY: sqScaleY}}, dT - config.SQUISH_TIME)					.to(bottomTile.iconSprite, config.SQUISH_TIME / 2, {ease: "Linear.easeNone", x: 0, y: 0, pixi: {scaleX: 1, scaleY: 1}}, dT - (config.SQUISH_TIME / 2));				//Request another icon from above				if(this._above === "top") {					this.dropFinish(Match3Tile.tiles[bottomTile._above], count);				} else {					Match3Tile.tiles[this._above].dropGet(Match3Tile.tiles[bottomTile._above], count);				}			} else if(this._above !== "top") {				//We still don't need any new icons, but keep checking				Match3Tile.tiles[this._above].dropGet(Match3Tile.tiles[this._above], 0);			}		}		//Spawn in new icons to drop onto the board		dropFinish(bottomTile, count) {			let nextBottom = bottomTile;			//Find the distance between the bottom tile and the spawn point, use that to position all subsequent tiles			let firstNewIconPos = {				x: this.parent.x - nextBottom.parent.x + nextBottom._spawnOffset.x,				y: this.parent.y - nextBottom.parent.y + nextBottom._spawnOffset.y			}; //"this" is always the tile at the top of the board			for(let i = 0; i < count; i++) {				nextBottom.iconSprite.position.set(firstNewIconPos.x,firstNewIconPos.y);				if(Match3Tile.swapAlarm) {					nextBottom.icon = Match3Tile.pickIcon("lowSwaps");					Match3Tile.swapAlarm = false;				} else {					nextBottom.icon = Match3Tile.pickIcon();				}				msgBus.publish("Game0.dropStarted", {tile: nextBottom});				Match3Tile.dropping++;				let dX = nextBottom.iconSprite.x;				let dY = nextBottom.iconSprite.y;				let dT = maths.vec2Length(dX, dY) / Match3Tile.dropSpeed;				let sqScaleX = 1, sqScaleY = 1, sqDX = 0, sqDY = 0;				if(Math.abs(dX) > 1) {					sqScaleX = 1 - (config.SQUISH_MIN - ((config.SQUISH_MIN - config.SQUISH_MAX) * (Math.abs(dX) / config.gameBoardMax.width)));					sqDX = -Math.sign(dX) * (1 - sqScaleX) * nextBottom.iconSprite.width;				}				if(Math.abs(dY) > 1) {					sqScaleY = 1 - (config.SQUISH_MIN - ((config.SQUISH_MIN - config.SQUISH_MAX) * (Math.abs(dY) / config.gameBoardMax.height)));					sqDY = -Math.sign(dY) * (1 - sqScaleY) * nextBottom.iconSprite.height;				}				new Timeline({					onComplete: (tile) => {						if(audio.exists(config.audioSpawnLookup[this.icon])) {							audio.play(config.audioSpawnLookup[this.icon]);						}						this.iconSprite.x = 0;						this.iconSprite.y = 0;						msgBus.publish("Game0.dropFinished", {tile: tile});						Match3Tile.dropping--;						if(Match3Tile.dropping === 0) {							msgBus.publish("Game0.allDropsFinished");						}					},					onCompleteParams: [nextBottom]				})					.to(nextBottom.iconSprite, dT - (config.SQUISH_TIME / 2), {ease: "Linear.easeNone", x: sqDX, y: sqDY})					.to(nextBottom.iconSprite, config.SQUISH_TIME / 2, {ease: "Linear.easeNone", pixi: {scaleX: sqScaleX, scaleY: sqScaleY}}, dT - config.SQUISH_TIME)					.to(nextBottom.iconSprite, config.SQUISH_TIME / 2, {ease: "Linear.easeNone", x: 0, y: 0, pixi: {scaleX: 1, scaleY: 1}}, dT - (config.SQUISH_TIME / 2));				nextBottom = Match3Tile.tiles[nextBottom._above];			}		}		//initiate drop process for a tile column		drop(spawnOffset) {			if(typeof spawnOffset === "object") {				this._spawnOffset.x = spawnOffset.x || 0;				this._spawnOffset.y = spawnOffset.y || -Match3Tile.HEIGHT;			}			this.dropGet(this, 0);		}		//UTILITY / MISC		//Returns true if a tile has a neighbouring wild icon		neighbouringWild() {			let nIDs = this._neighboursX.concat(this._neighboursY);			for(let i = 0; i < nIDs.length; i++) {				if(Match3Tile.tiles[nIDs[i]]._iconType === "wild") {					return true;				}			}			return false;		}		//Returns the tileID opposite neighbour, if there is one		neighbourOppositeTo(neighbour) {			let nID = (typeof neighbour === "object") ? neighbour.id : neighbour;			let iX = this._neighboursX.indexOf(nID);			let iY = this._neighboursY.indexOf(nID);			let opposite;			if(iX > -1 && this._neighboursX.length > 1) {				opposite = this._neighboursX[iX === 0 ? 1 : 0];			} else if(iY > -1 && this._neighboursY.length > 1) {				opposite = this._neighboursY[iY === 0 ? 1 : 0];			}			return opposite;		}		//returns an array of all the tile neighbours that are physically on a line between this tile and x, y		allNeighboursToPoint(x, y) {			return Object.keys(Match3Tile.tiles).filter(id => {				let other = Match3Tile.tiles[id].getGlobalPosition();				let left = other.x - (Match3Tile.WIDTH / 2);				let right = other.x + (Match3Tile.WIDTH / 2);				let top = other.y - (Match3Tile.HEIGHT / 2);				let bottom = other.y + (Match3Tile.HEIGHT / 2);				return id !== this.id && maths.lineIntersectsRectangle(this.getGlobalPosition(), {x: x, y: y}, left, top, right, bottom);			});		}		//returns an array of all the tile neighbours facing in the direction opposite neighbour		allNeighboursOppositeTo(neighbour) {			let nOp = this.neighbourOppositeTo(neighbour);			return nOp ? [this.id].concat(Match3Tile.tiles[nOp].allNeighboursOppositeTo(this.id)) : [this.id];		}		//Returns true if this tile equals the other tile according to the equivalency rules.		equals(otherID) {			if(typeof otherID === "undefined" || this._iconType === "instant" || Match3Tile.tiles[otherID]._iconType === "instant") {				//instant tiles never match with anything				return false;			} else {				return ((this._tintFamily !== "none") !== (Match3Tile.tiles[otherID]._tintFamily !== "none")) ||					(this._tintFamily !== "none" && this._tintFamily === Match3Tile.tiles[otherID]._tintFamily);			}		}		//Getter/setter for icons		get icon() {			return this._icon;		}		//when changing the icon, update other icon fields		set icon(val) {			this._tintFamily = "none";			if(val === "none") {				this._icon = "none";				this._iconType = "none";				this._iconFamily = "none";				this._tintFamily = "none";				this.iconSprite.textures = [PIXI.Texture.EMPTY];			} else {				let data = Match3Tile.iconData(val);				this._icon = data.name;				this._iconType = data.type;				this._iconFamily = data.family;				if(data.type === "base") {					this._tintFamily = data.family;				}				let popFrames = Match3Tile.getPopFrames(this._icon);				this.iconSprite.textures = popFrames.map(frame => {return PIXI.Texture.fromFrame(frame);});				this.iconSprite.animationSpeed = config.ANIM_SPEED_ICON;				this.iconSprite.loop = true;				this.iconSprite.gotoAndPlay(0);				//Set anchor to match texture's default				this.iconSprite.anchor.set(this.iconSprite.texture.defaultAnchor.x, this.iconSprite.texture.defaultAnchor.y);			}			this._dirty = true;		}		get popVal() {			return Math.max(this._popX, this._popY);		}	}	return Match3Tile;});