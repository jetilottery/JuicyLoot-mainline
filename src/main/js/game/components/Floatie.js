define((require) => {	const PIXI = require("com/pixijs/pixi");	const displayList = require("skbJet/componentManchester/standardIW/displayList");	const maths = require("skbJet/componentLondon/utils/maths");	require("com/gsap/TweenMax");	require("com/gsap/TimelineLite");	require("com/gsap/easing/EasePack");	const Timeline = window.TimelineLite;	//Avoid using maths.iRandomRange so we don't pollute the seed	function iRandomRange(min, max) {		return (Math.random() * (max - min)) + min;	}	function mitchellBestCandidate(total, rect) {		let points = [new PIXI.Point(iRandomRange(rect.left, rect.right), iRandomRange(rect.top, rect.bottom))];		for(let j = 0; j < total; j++) {			let candidates = [];			for(let i = 0; i < 10; i++) {				let minX = Math.max(rect.left, points[points.length - 1].x - rect.width / 2);				let maxX = Math.min(rect.right, points[points.length - 1].x + rect.width / 2);				let minY = Math.max(rect.top, points[points.length - 1].x - rect.height / 2);				let maxY = Math.min(rect.bottom, points[points.length - 1].x + rect.height / 2);				candidates.push(new PIXI.Point(iRandomRange(minX, maxX), iRandomRange(minY, maxY)));			}			let bestDist = 0;			let bestCandidate = 0;			for(let i = 0; i < candidates.length; i++) {				let dist = 0;				points.forEach(point => dist += maths.pointDistance(candidates[i], point));				if(dist > bestDist) {					bestDist = dist;					bestCandidate = i;				}			}			points.push(candidates[bestCandidate]);		}		return points;	}	class Floatie extends PIXI.Container {		static spawn(from, icon, layer) {			let floatie = new Floatie(icon);			layer = layer || displayList.particleLayer;			layer.addChild(floatie);			from.getGlobalPosition(floatie.position);			return floatie;		}		static popFadeAndFall(tile, offset, min, max) {			offset = offset || 0;			let floatLayer = new PIXI.Container();			let total = iRandomRange((min || 35), (max || 40));			let rect = new PIXI.Rectangle(-tile.WIDTH, -tile.HEIGHT, tile.WIDTH * 2, tile.HEIGHT * 2);			let points = mitchellBestCandidate(total, rect);			for(let i = 0; i < points.length; i++) {				let floatie = Floatie.spawn(tile, tile.icon, floatLayer);				floatie.position.set(points[i].x, points[i].y);				floatie.scale.set(iRandomRange(0.3, 1));				floatie.rotation = Math.random() * Math.PI * 2;			}			floatLayer.scale.set(0.5);			floatLayer.visible = 0;			tile.addChild(floatLayer);			floatLayer.position.set(offset.x, offset.y);			new Timeline({				onComplete: () => { floatLayer.parent.removeChild(floatLayer); }			})				.to(floatLayer, 0.3, {pixi: {scaleX: 1, scaleY: 1}, visible: true})				.to(floatLayer, 1, {alpha: 0, y: "+=37"}, "+=0");		}		constructor(icon) {			super();			this.particleFrame = Math.random() > 0.5 ? "particle1" + icon : "particle2" + icon;			this.particle = new PIXI.Sprite(PIXI.Texture.fromFrame(this.particleFrame));			this.particle.anchor.set(0.5);			this.addChild(this.particle);		}	}	return Floatie;});