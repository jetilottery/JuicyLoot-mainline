define(require => {	const PIXI = require("com/pixijs/pixi");	const app = require("skbJet/componentManchester/standardIW/app");	const Pressable = require("skbJet/componentManchester/standardIW/components/pressable");	const autoPlay = require("skbJet/componentManchester/standardIW/autoPlay");	const utils = require("skbJet/componentManchester/standardIW/layout/utils");	const meterData = require("skbJet/componentManchester/standardIW/meterData");	const audio = require("skbJet/componentManchester/standardIW/audio");	const SKBeInstant = require("skbJet/component/SKBeInstant/SKBeInstant");	const FittedText = require("skbJet/componentManchester/standardIW/components/fittedText");	const textStyles = require("skbJet/componentManchester/standardIW/textStyles");	const filterStyles = require("game/template/filterStyles");	const Floatie = require("game/components/Floatie");	require("com/gsap/TweenMax");	require("com/gsap/easing/EasePack");	const Tween = window.TweenMax;	const Timeline = window.TimelineLite;	class InstantWinTile extends Pressable {		static fromContainer(container) {			const tile = new InstantWinTile();			container.addChild(tile);			InstantWinTile.tileArray.push(tile);			return tile;		}		//Cycle through the list of keys so we don't get two matching tiles in a row		static pickKey() {			let key = InstantWinTile.iconKeys.pop();			InstantWinTile.iconKeys.unshift(key);			return key;		}		constructor() {			super();			InstantWinTile.iconKeys = InstantWinTile.iconKeys || ["Pear", "Apple", "Blueberry", "Lemon", "Orange", "Blackberry"];			InstantWinTile.tileArray = InstantWinTile.tileArray || [];			this.WIDTH = 164;			this.HEIGHT = 244;			// Create all the empty sprites			this.icon = InstantWinTile.pickKey();			this.background = new PIXI.Sprite(PIXI.Texture.EMPTY);			this.win = new FittedText("", textStyles.parse("prizeValueWin"));			this.noWin = new FittedText("", textStyles.parse("prizeValueNoWin"));			this.instantWin = false;			this.revealAnim = new PIXI.extras.AnimatedSprite(utils.findFrameSequence("match3Glass" + this.icon + "DrainAnim").map(frame => {return PIXI.Texture.fromFrame(frame);}));			this.revealAnim.loop = false;			this.revealAnim.animationSpeed = 0.5;			this.revealAnim.visible = false;			this.comboSquare = new PIXI.Sprite(PIXI.Texture.fromFrame("comboSelectionSquare"));			this.comboBurst = new PIXI.Sprite(PIXI.Texture.fromFrame("comboBurst"));			this.bubbleAnim = new PIXI.extras.AnimatedSprite(utils.findFrameSequence("bubbles" + this.icon).map(frame => {return PIXI.Texture.fromFrame(frame);}));			this.bubbleAnim.loop = false;			this.idleAnim = new PIXI.extras.AnimatedSprite(utils.findFrameSequence("match3Glass" + this.icon + "StaticAnim").map(frame => {return PIXI.Texture.fromFrame(frame);}));			this.idleAnim.loop = true;			this.idleAnim.animationSpeed = 0.25;			this.idleAnim.gotoAndPlay(Math.round(Math.random() * this.idleAnim.textures.length));			// Center everything			this.background.anchor.set(0.5);			this.win.anchor.set(0.5);			this.noWin.anchor.set(0.5);			this.revealAnim.anchor.set(0.5);			this.idleAnim.anchor.set(0.5);			//Add outlines			this.win.filters = [filterStyles.prizeWin0, filterStyles.prizeWin1, filterStyles.prizeShadow];			this.noWin.filters = [filterStyles.prizeNoWin, filterStyles.prizeShadow];			// Add all the result elements to a container			this.resultContainer = new PIXI.Container();			this.resultContainer.addChild(this.comboSquare, this.comboBurst, this.win, this.noWin);			this.resultContainer.visible = false;			this.comboBurst.visible = false;			this.comboSquare.visible = false;			this.bubbleAnim.visible = false;			this.resultContainer.name = "resultContainer";			this.addChild(this.background, this.revealAnim, this.bubbleAnim, this.resultContainer, this.idleAnim);			// State			this.revealed = false;			// Interactivity			this.hitArea = new PIXI.Rectangle(				this.WIDTH / -2,				this.HEIGHT / -2,				this.WIDTH,				this.HEIGHT			);			this.on("press", () => {				if (!autoPlay.enabled) {					this.reveal();				}			});			this.enabled = false;			this.dbg = {};		}		enable() {			return new Promise(resolve => {				this.reveal = resolve;				this.enabled = true;			}).then(() => {				this.enabled = false;			});		}		populate(number) {			//number = Math.round(Math.random() * 100000000); //This is for debugging fixOverlaps			if(String(number).includes("IW")) {				this.instantWin = true;				number = number.slice(2);			}			this.number = number;			this.win.text = this.noWin.text = SKBeInstant.formatCurrency(number).formattedAmount;			if(this.instantWin) {				this.win.style.fill = 0xD900DE;				this.win.filters = [filterStyles.prizeNoWin, filterStyles.prizeShadow];			} else {				this.win.style.fill = 0xEFDD00;			}		}		prompt() {			if (!this.revealed && this.idleAnim.textures.length > 1) {				this.revealAnim.visible = false;				this.idleAnim.visible = true;				this.idleAnim.gotoAndPlay(0);			}		}		disable() {			this.enabled = false;			this.reveal = undefined;		}		reset() {			//Remove from tileArray and scene			InstantWinTile.tileArray.splice(InstantWinTile.tileArray.indexOf(this), 1);			if(this.parent !== null) {				this.parent.removeChild(this);			}		}		async uncover() {			if(this.revealAnim.textures && this.revealAnim.textures.length > 1) {				await new Promise(resolve => {					// bring to front in case the animation overlaps neighboring tiles					this.revealAnim.parent.parent.setChildIndex(						this.revealAnim.parent,						this.revealAnim.parent.parent.children.length - 1					);					this.resultContainer.visible = true;					if(this.testWin()) {						this.win.visible = true;						this.noWin.visible = false;					} else {						this.win.visible = false;						this.noWin.visible = true;					}					//There's a possible race condition here, so let's try and mitigate that.					let timelineFinished = false;					let bubbleFinished = false;					new Timeline({						onComplete: () => {							if(bubbleFinished) {								resolve();							} else {								timelineFinished = true;							}						}					})						.fromTo(this.resultContainer, 0.25,							{ alpha: 0, y: 62, pixi: {scaleX: 0.5, scaleY: 0.5} },							{ alpha: 1, y: -31, pixi: {scaleX: 1, scaleY: 1.2} , ease: "Back.easeOut.config(1.7)"}						, 0.8333333)						.call(() => {							this.bubbleAnim.visible = true;							this.bubbleAnim.gotoAndPlay(0);							audio.play("bonusReveal");						}, [], this, 0.75)						.call((winNow) => {							if(winNow) {								let winners = [this];								this.match();								this.presentWin();								audio.play(this.instantWin ? "bonusInstant" : "bonusMatch");								InstantWinTile.tileArray.forEach(tile => {									if(!tile.matched && tile.revealed && tile.testWin()) {										tile.match();										tile.presentWin();										winners.push(tile);									}								});								console.log("SET METERDATA FOR TILE: " + InstantWinTile.tileArray.indexOf(this));								meterData.win += parseInt(this.number);								Tween.delayedCall(0.2, () => {									winners.forEach(tile => {										if(tile.instantWin) {											Floatie.popFadeAndFall(tile, {x:0, y: -40}, 60, 80);										} else {											Floatie.popFadeAndFall(tile, {x: 0, y: -40});										}									});								});							}						}, [this.testWin()], this, 1.25);					// Wait for the animation to complete before resolving					this.bubbleAnim.onComplete = () => {						this.revealed = true;						this.bubbleAnim.visible = false;						if(timelineFinished) {							resolve();						} else {							bubbleFinished = true;						}					};					// Disable interactivity to prevent re-reveal, then switch to the animation					this.enabled = false;					this.idleAnim.visible = false;					this.revealAnim.visible = true;					this.revealAnim.gotoAndPlay(0);					audio.play("bonusUncover");				});			} else {				// Otherwise just a swap to the resultsContainer				this.resultContainer.visible = true;				this.revealAnim.visible = false;				this.background.visible = true;				this.revealed = true;			}		}		showBounds() {			let resultBounds = this.win.visible ? this.win.getBounds() : this.noWin.getBounds();			if(this.dbg.g) {				this.dbg.g.parent.removeChild(this.dbg.g);				delete this.dbg.g;			}			this.dbg.g = new PIXI.Graphics();			app.stage.addChild(this.dbg.g);			this.dbg.g.beginFill(0xFF0000, 0.3);			this.dbg.g.drawRect(resultBounds.x, resultBounds.y, resultBounds.width, resultBounds.height);		}		hideBounds() {			if(this.dbg.g) {				this.dbg.g.parent.removeChild(this.dbg.g);				delete this.dbg.g;			}		}		match() {			this.matched = true;			this.win.visible = true;			this.noWin.visible = false;		}		testWin() {			let acc = 0;			InstantWinTile.tileArray.forEach(elem => {if(elem.number === this.number){acc++;}}); //This should probably be a reduce function			return acc >= 3 || this.instantWin;		}		getOverlaps() {			let thisResult = this.win.visible ? this.win : this.noWin;			let thisResultBounds = thisResult.getBounds().clone();			thisResultBounds.pad(10, 0);			let resultBounds;			return InstantWinTile.tileArray.filter(tile => {				resultBounds = tile.win.visible ? tile.win.getBounds() : tile.noWin.getBounds();				return(					tile !== this &&					resultBounds.top < thisResultBounds.bottom &&					resultBounds.bottom > thisResultBounds.top &&					resultBounds.left < thisResultBounds.right &&					resultBounds.right > thisResultBounds.left				);			}).map(tile => tile.resultContainer);		}		fixOverlaps() {			//Check if the resultContainer bounds overlap with a neighbouring tile. If they do, shrink both containers to fit.			let overlapping = this.getOverlaps();			let lastScale;			if(overlapping.length) {				overlapping.push(this.win.visible ? this.win : this.noWin);				lastScale = overlapping.reduce((acc, elem) => {return acc.scale.x > elem.scale.x ? acc : elem;}).scale.x;				Tween.to(overlapping, 0.25, {					onComplete: (tile) => {						tile.fixOverlaps();						if(tile.dbg.g) {							tile.showBounds();						}					},					onCompleteParams: [this],					pixi: {scaleX: lastScale * 0.9},					ease: "Linear.easeNone"				});			}		}		presentWin() {			//bring winning tile to front			this.parent.parent.setChildIndex(this.parent, this.parent.parent.children.length - 1);			Tween.fromTo(this.comboBurst, 2.4166, {pixi: {rotation: 0}}, {				pixi: {rotation: 360},				repeat: -1,				ease: "Linear.easeNone"			});			new Timeline({				onComplete: (tile) => {tile.fixOverlaps();},				onCompleteParams: [this]			})				.to(this.win, 0.25, {alpha: 1, pixi: {scaleX: 1.4, scaleY: 1.4}, ease: "Linear.easeNone"}, 0)				.to(this.win, 0.2083, {pixi: {scaleX: 1, scaleY: 1.2}, ease: "Linear.easeNone"}, 0.25)				.to(this.noWin, 0, { alpha: 0, visible: false, ease: "Linear.easeNone"}, 0.25)				.fromTo(this.comboSquare, 0.125, {visible: false, pixi: {scaleX: 0.8, scaleY: 0.8}}, {					visible: true,					pixi: {scaleX: 1, scaleY: 1}				}, 0.0417)				.fromTo(this.comboBurst, 0.125, {visible: false}, {visible: true}, 0.0417);		}	}	return InstantWinTile;});