define(function(require) {	const gameFlow = require("skbJet/componentManchester/standardIW/gameFlow");	const meterData = require("skbJet/componentManchester/standardIW/meterData");	const audio = require("skbJet/componentManchester/standardIW/audio");	const config = require("skbJet/componentManchester/standardIW/gameConfig");		const PIXI = require("com/pixijs/pixi");	const filterStyles = require("game/template/filterStyles");	const displayList = require("skbJet/componentManchester/standardIW/displayList");	const resLib = require("skbJet/component/resourceLoader/resourceLib");	require("com/gsap/TweenMax");	const Tween = window.TweenMax;	let losingFruit;	let winningFruit;	function init() {		let pear, apple, blueberry, lemon, orange, blackberry;		//Add lose plaque		pear = new PIXI.spine.Spine(resLib.spine.pearLose.spineData);		apple = new PIXI.spine.Spine(resLib.spine.appleLose.spineData);		blueberry = new PIXI.spine.Spine(resLib.spine.blueberryLose.spineData);		lemon = new PIXI.spine.Spine(resLib.spine.lemonLose.spineData);		orange = new PIXI.spine.Spine(resLib.spine.orangeLose.spineData);		blackberry = new PIXI.spine.Spine(resLib.spine.blackberryLose.spineData);		displayList.losePlaqueBG.addChild(blueberry, blackberry, pear, orange, apple);		displayList.loseLemon.addChild(lemon);		losingFruit = [blueberry, blackberry, pear, orange, apple, lemon];		//add win plaque		pear = new PIXI.spine.Spine(resLib.spine.pear.spineData);		apple = new PIXI.spine.Spine(resLib.spine.apple.spineData);		blueberry = new PIXI.spine.Spine(resLib.spine.blueberry.spineData);		lemon = new PIXI.spine.Spine(resLib.spine.lemon2.spineData);		orange = new PIXI.spine.Spine(resLib.spine.orange.spineData);		blackberry = new PIXI.spine.Spine(resLib.spine.blackberry2.spineData);		displayList.winPlaqueBG.addChild(blueberry, blackberry, pear, orange, apple, lemon);		displayList.winLemon.addChild(lemon);		winningFruit = [blueberry, blackberry, pear, orange, apple, lemon];				//Put an outline around the resultPlaques		displayList.winPlaqueBG.filters = [filterStyles.resultPlaques];		displayList.losePlaqueBG.filters = [filterStyles.resultPlaques];		//Animate fruit randomly		winningFruit.concat(losingFruit).forEach(fruit => {			fruit.state.addListener({				complete: () => {					Tween.delayedCall(Math.random() * config.FRUIT_ANIMATE_GAP_MAX, (fruit) => {						fruit.state.setAnimation(0, fruit.spineData.animations[0].name, false);					}, [fruit]);				}			});			fruit.state.setAnimation(0, fruit.spineData.animations[0].name, false);		});		displayList.winPlaqueCloseButton.on("press", () => {			Tween.to(displayList.winPlaqueEffects, config.POPUP_FADE_TIME, {alpha: 0});		});	}	function resultScreen() {		// ResultPlaques template component handles populating and showing the result screen		const winner = meterData.totalWin > 0;		const terminator = winner ? "bonusResultWin" : "bonusResultNoWin";		audio.fadeOut("musicBonus", config.resultMusicFadeOutDuration);		Tween.delayedCall(config.resultTerminatorFadeInDelay, () => {			audio.fadeIn(terminator, config.resultTerminatorFadeInDuration, false);			if(winner) {				displayList.winPlaqueEffects.parent.setChildIndex(displayList.winPlaqueEffects, 3);				Tween.fromTo(displayList.winPlaqueEffects, config.POPUP_FADE_TIME, {alpha: 0}, {alpha: 1});			} else {				displayList.winPlaqueEffects.alpha = 0;			}		});		let starBursts = [displayList.plaqueBurst0, displayList.plaqueBurst1, displayList.plaqueBurst2];		let starShines = [displayList.plaqueShine0, displayList.plaqueShine1, displayList.plaqueShine2];		//stagger is probably unnecessary but just in case animating in sync looks weird		starBursts.forEach(elem => elem.rotation = 0);		starShines.forEach(elem => elem.rotation = 0);		Tween.staggerTo(starBursts, config.RESULTS_BURST_ANIM_TIME * 2, {			pixi: {rotation: 360},			repeat: -1,			ease: "Linear.easeNone"		}, config.RESULTS_BURST_ANIM_TIME / 3);		Tween.staggerTo(starShines, config.RESULTS_SHINE_ANIM_TIME * 2, {			pixi: {rotation: -360},			repeat: -1,			ease: "Linear.easeNone"		}, config.RESULTS_SHINE_ANIM_TIME / 3);	}	gameFlow.handle(resultScreen, "RESULT_SCREEN");	return {		init: init	};});